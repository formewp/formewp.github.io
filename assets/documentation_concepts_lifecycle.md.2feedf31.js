import{_ as e,o as t,c as o,V as i}from"./chunks/framework.364d6ed5.js";const g=JSON.parse('{"title":"Lifecycle","description":"","frontmatter":{},"headers":[],"relativePath":"documentation/concepts/lifecycle.md","filePath":"documentation/concepts/lifecycle.md","lastUpdated":1684573531000}'),a={name:"documentation/concepts/lifecycle.md"},s=i('<h1 id="lifecycle" tabindex="-1">Lifecycle <a class="header-anchor" href="#lifecycle" aria-label="Permalink to &quot;Lifecycle&quot;">​</a></h1><p>This document provides an overview of the request lifecycle in Forme, including initialisation processes and bootstrapping. Understanding this lifecycle will help you grasp how the framework manages operations.</p><h2 id="the-lifecycle" tabindex="-1">The Lifecycle <a class="header-anchor" href="#the-lifecycle" aria-label="Permalink to &quot;The Lifecycle&quot;">​</a></h2><p>In WordPress, all requests pass through the <code>index.php</code> file, which serves as the front controller. The <code>index.php</code> file bootstraps WordPress, including loading plugins, running the theme&#39;s <code>functions.php</code>, determining the template to be used, and rendering HTML.</p><p>If you are familiar with Laravel, you can think of <code>bootstrap/app.php</code> as the equivalent entry point in the lifecycle. This comes immediately after the <code>index.php</code> entry point (which includes the composer autoload), and takes care of instantiating the Laravel app.</p><p>Forme leverages default WordPress files to achieve a similar flow within the WordPress lifecycle.</p><p>During set up, we include our autoload in <code>wp-config.php</code> and define the <code>FORME_PRIVATE_ROOT</code> constant.</p><p>Regarding bootstrapping:</p><ul><li>For themes, we use <code>functions.php</code> for bootstrapping.</li><li>For plugins, we use the plugin bootstrap file.</li></ul><p>This ensures that Forme bootstraps and runs before any pages in the template hierarchy.</p><h2 id="bootstrapping" tabindex="-1">Bootstrapping <a class="header-anchor" href="#bootstrapping" aria-label="Permalink to &quot;Bootstrapping&quot;">​</a></h2><p>The bootstrap file performs the following steps:</p><ul><li>Checks the <code>WP_ENV</code> constant and loads Whoops if we are in development mode and it is not already loaded.</li><li>Loads the dotenv file if it exists and is not already loaded.</li><li>Includes the custom routes file. Any routes defined here will be registered with the relevant WordPress hooks.</li><li>Instantiates the Forme theme or plugin object. This object&#39;s main task is to initialise the Forme Framework loader.</li><li>The loader calls <code>Forme\\getContainer()</code>, which uses the singleton pattern to create the application container if it doesn&#39;t already exist or retrieve it if it does.</li><li>The container includes a logger (via Monolog) and a database connection (via Capsule, booted with Eloquent).</li><li>The loader registers all hooks defined in the <code>app/config/hooks.yaml</code> file, ensuring that the relevant classes/methods are called through the container.</li><li>It also sets up the Template handler, allowing the use of Template controllers in Forme themes.</li><li>For plugins, the bootstrap file sets up activation and deactivation files, along with related admin notices. This includes database schema migrations for plugins. Themes handle this differently, as they can be tied to a hook, specified in the <code>hooks.yaml</code> file.</li><li>For themes, the bootstrap starts a session if one isn&#39;t already in progress.</li></ul><p>You generally won&#39;t need to modify the bootstrap/functions.php file, although you can refer to it if you require early access to certain components in the lifecycle.</p><div class="tip custom-block"><p class="custom-block-title">What no functions.php?</p><p>Nope! Global functions are placed in helpers.php and should primarily be used within your views. Anything else probably wants to be in a class.</p></div><h2 id="routing" tabindex="-1">Routing <a class="header-anchor" href="#routing" aria-label="Permalink to &quot;Routing&quot;">​</a></h2><p>Each of our HTTP route handling strategies intercepts WordPress using a relevant hook and takes control from there if the route matches.</p><p>The Custom Route strategy inserts itself before any core WordPress routing occurs.</p><p>The other strategies do not interfere with core WordPress routing; they only handle the request and response parts.</p><p>Each strategy runs after WordPress has loaded but before it has sent any page output. Therefore, you can generally rely on WordPress functionality being available as expected.</p><p>The specific hooks used for each strategy are as follows, which may be useful for debugging:</p><ul><li>Custom Routes - <code>wp_loaded</code></li><li>Ajax Private Routes - <code>wp_ajax_$route_name</code></li><li>Ajax Public Routes - <code>wp_ajax_nopriv_$route_name</code></li><li>Rest Routes - <code>rest_api_init</code></li><li>WordPress Routes aka Template Controllers - <code>template_include</code></li></ul><p>After gaining control, each route handling strategy performs the following steps:</p><ul><li>Retrieves the PSR-15 middleware queue configured for the corresponding route.</li><li>Adds its own handler to the end of the queue to provide the final HTTP response.</li><li>Retrieves the PSR-7 Request.</li><li>Dispatches the full queue using <a href="https://relayphp.com/" target="_blank" rel="noreferrer">Relay</a>.</li><li>Forces shutdown, meaning control is <em>not</em> handed back to WordPress.</li></ul>',24),n=[s];function r(l,c,d,h,p,u){return t(),o("div",null,n)}const m=e(a,[["render",r]]);export{g as __pageData,m as default};
