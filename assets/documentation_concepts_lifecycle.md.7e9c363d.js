import{_ as e,o as t,c as o,V as a}from"./chunks/framework.364d6ed5.js";const m=JSON.parse('{"title":"Lifecycle","description":"","frontmatter":{},"headers":[],"relativePath":"documentation/concepts/lifecycle.md","filePath":"documentation/concepts/lifecycle.md","lastUpdated":1684512137000}'),i={name:"documentation/concepts/lifecycle.md"},s=a('<h1 id="lifecycle" tabindex="-1">Lifecycle <a class="header-anchor" href="#lifecycle" aria-label="Permalink to &quot;Lifecycle&quot;">​</a></h1><p>This will give you an overview of the request lifecycle, how and what Forme initialises and where the bootstrapping happens. It&#39;s useful to get a handle on how things are managed within the framework.</p><h2 id="the-lifecycle" tabindex="-1">The Lifecycle <a class="header-anchor" href="#the-lifecycle" aria-label="Permalink to &quot;The Lifecycle&quot;">​</a></h2><p>As WordPress uses a front controller, all requests go through the index.php file. This then bootstraps WordPress including plugins, runs the theme&#39;s <code>functions.php</code>, finds which template to load in your theme and then renders some HTML.</p><p>If you&#39;ve worked with Laravel, you&#39;ll be familiar with <code>bootstrap/app.php</code>. In terms of the lifecycle, this comes immediately after the <code>index.php</code> entry point (which includes the composer autoload), and takes care of instantiating the Laravel app.</p><p>Forme takes advantage of default WordPress files to achieve a similar flow within the WordPress lifecycle.</p><p>During set up, we&#39;ve shoe-horned our autoload include into <code>wp-config.php</code> and set up the <code>FORME_PRIVATE_ROOT</code> constant.</p><p>As for the bootstrap:</p><ul><li>for themes we use <code>functions.php</code> for this purpose</li><li>for plugins we use the plugin bootstrap file</li></ul><p>This means Forme bootstraps and runs before any pages in the template hierarchy.</p><h2 id="bootstrapping" tabindex="-1">Bootstrapping <a class="header-anchor" href="#bootstrapping" aria-label="Permalink to &quot;Bootstrapping&quot;">​</a></h2><ul><li>The bootstrap file checks the <code>WP_ENV</code> constant and loads Whoops if we&#39;re in development mode and if it it&#39;s not already loaded.</li><li>It loads up the dotenv if it exists and if it&#39;s not already loaded.</li><li>It includes the custom routes file. Any routes defined here will get registered to the relevant WordPress hooks.</li><li>It instantiates the Forme theme or plugin object. This object&#39;s main task is to boot up the Forme Framework loader</li><li>The loader calls <code>Forme\\getContainer()</code> which uses the singleton pattern to create the application container if it doesn&#39;t exist already or grab it if it does</li><li>The container gets a logger (via Monolog) and database connection (via Capsule, booted with Eloquent)</li><li>The loader then takes care of registering all the hooks which we&#39;ve defined in our <code>app/config/hooks.yaml</code> file, making sure the relevant classes/methods get called via the container.</li><li>It will also hook up the Template handler, which will enable us to use Template controllers in Forme themes.</li><li>In plugins, the boostrap file then sets up the activation and deactivation files and related admin notices. These include the database schema migrations for the plugins. These are handled differently for themes, since they can be tied to a hook, i.e. in the <code>hooks.yaml</code> file.</li><li>In themes, the bootstrap starts a session if there isn&#39;t already one in process</li></ul><p>You shouldn&#39;t really need to touch the bootstrap/functions.php file, although this is where you would look if you need access to things early on in the lifecycle.</p><div class="tip custom-block"><p class="custom-block-title">What no functions.php?</p><p>Nope! Global functions go in helpers.php and these should only really be for use in your views. Anything else probably wants to be in a class. More on that later.</p></div><h2 id="routing" tabindex="-1">Routing <a class="header-anchor" href="#routing" aria-label="Permalink to &quot;Routing&quot;">​</a></h2><p>Each of our HTTP route handling strategies interrupts WordPress using a relevant hook and takes things over from there if the route matches.</p><p>The Custom Route strategy inserts itself before any WordPress core routing happens.</p><p>None of the other strategies interfere with core WordPress routing, they just take over the request and response handling part.</p><p>Each one runs after WordPress has loaded, but before it has sent any page output. This means you can generally rely on WordPress functionality being available as you would expect.</p><p>The specific hooks are as follows, which may be useful for debugging:</p><ul><li>Custom Routes - <code>wp_loaded</code></li><li>Ajax Private Routes - <code>wp_ajax_$route_name</code></li><li>Ajax Public Routes - <code>wp_ajax_nopriv_$route_name</code></li><li>Rest Routes - <code>rest_api_init</code></li><li>WordPress Routes aka Template Controllers - <code>template_include</code></li></ul><p>Each route handling strategy performs the following steps after it has gained control:</p><ul><li>grabs the PSR-15 middleware queue as configured for the route in question</li><li>adds its own handler to the end of the queue to provide the final http response</li><li>grabs the PSR-7 Request</li><li>dispatches the full queue using <a href="https://relayphp.com/" target="_blank" rel="noreferrer">Relay</a></li><li>forces shutdown - i.e. it does <em>not</em> hand control back to WordPress.</li></ul>',23),l=[s];function n(r,h,c,d,p,u){return t(),o("div",null,l)}const g=e(i,[["render",n]]);export{m as __pageData,g as default};
